### 1) SQL 중심적 개발이 문제점

우리는 객체지향언어를 통해 개발을 한다. 그리고 객체들의 정보를 대부분 관계형 데이터베이스에 저장한다.

그리고, 객체와 관계형 데이터베이스에는 다음과 같은 차이가 있다.

- 상속
- 연관관계
- 데이터 타입
- 데이터 식별방법

따라서, 이런 차이에서 오는 문제가 발생할 수 밖에 없다.

##### 1-1) 상속

![JPA](https://user-images.githubusercontent.com/59816811/116509967-26710500-a8ff-11eb-971f-140a9458f50f.png)

Item의 카테고리로 Album, Movie, Book이 있는 상황을 생각해보자. 객체는 왼쪽 그림과 같이 상속을 이용해서 설계를 하면 된다. 그리고 DB는 오른쪽 그림과 같이 설계하게 된다.

**[ Album 저장하는 상황 ]**

객체는 Album 객체를 생성해서 값을 넣어주면 된다.

데이터베이스는 ITEM, ALBUM 테이블 2개를 Insert 해야된다.

**[ Album 을 조회하는 상황 ]**

각각의 테이블에서 Item, Album 정보를 받아오고, 각각의 객체를 생성해서 정보를 넣어주는 등 복잡한 상황이 발생한다.

##### --> DB에 저장할 객체에는 상속 관계를 사용하기 어렵다.

<br>

##### 1-2) 연관관계

![JPA_2](https://user-images.githubusercontent.com/59816811/116510313-b020d280-a8ff-11eb-8056-2d0d6d86af00.png)

Member 객체는 Team 객체를 하나씩 포함하고 있다고 하자.

그러면, 객체는 Member.getTeam() 을 이용해서 Team을 참조할 수 있지만, 테이블은 외래키를 사용해야된다.

또, 테이블에서는 TEAM 에서도 MEMBER 테이블을 참조할 수 있고, MEMBER 테이블도 TEAM 테이블을 참조할 수 있지만 객체는 아니다.

더 나아가 Member 객체에 주문한 데이터에 대한 정보 Order 클래스가 추가되었다고 하자. Member 객체를 조회할 때, 어떻게 SQL 쿼리를 작성하느냐에 따라, Team, Order 객체 정보도 조회할지 결정되므로 우리는 Member 객체를 조회해도 Team, Order 객체 정보가 같이 넘어온지 바로 알 수 없다.

```java
memberDAO.getMember();
memberDAO.getMemberWithTeam();
memberDAO.getMemberWithTeamWithOrder();
```

 이처럼 우리가 그냥 객체 입장에서 생각하면 Member 객체에서 Order객체, Team 객체 모두 자유롭게 탐색할 수 있는 것이 맞으나! 테이블 설계상 그럴 수 없다.

##### --> 객체가 만약에 자바 컬렉션에 저장되어있다면, 객체 참조, 상속 등 문제가 없다.

##### --> 객체를 자바 컬렌셕에 저장하듯이 DB에 저장할 수는 없을까??

##### --> JPA 등장!!!! ( ORM )

<br>

### 2) JPA

JPA는 자바 진영의 **ORM** 기술 표준으로 JAVA 애플리케이션과 JDBC 사이에서 동작한다.

> ORM
>
> - Object-Relational-Mapping
> - 객체는 객체대로 설계, 관계형 데이터베이스는 관계형 데이터베이스대로 설계하면 ORM이 중간에서 다리가 되어준다!

JPA를 사용하면 위에서 언급한 패러다임의 불일치로 나타나는 모든 문제가 해결된다.